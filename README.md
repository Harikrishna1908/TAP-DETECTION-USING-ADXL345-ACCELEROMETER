# TAP-DETECTION-USING-ADXL345-ACCELEROMETER
**Header Files:**
The code includes several header files that provide necessary definitions and function declarations for working with I2C, GPIO, and other functionalities on the ESP32:

_stdio.h:_ Standard input/output functions.

_driver/i2c.h:_ ESP32 I2C driver.

_driver/gpio.h:_ ESP32 GPIO driver.

_esp_log.h:_ ESP32 logging functions.

_sdkconfig.h:_ Configuration generated by the ESP-IDF build system.

_freertos/FreeRTOS.h and freertos/task.h: _Required for using FreeRTOS multitasking.

**Constants and Definitions:**
The code defines various constants related to I2C communication, GPIO pins, accelerometer registers, and other parameters. For example, it specifies the I2C port number, I2C communication speed, GPIO pins for the accelerometer interrupts (_INT_1_ and _INT_2_), sample period delay, and the I2C address of the ADXL345 accelerometer.


**I2C Master Initialization:**
The function _I2C_Master_Initialize()_ initializes the ESP32 as an I2C master by configuring the I2C communication parameters and installing the I2C driver.

_int i2c_master_port = I2C_PORT_NUM;:_
This line assigns the I2C port number to the variable i2c_master_port.
_I2C_PORT_NUM_ is a constant that defines which I2C port of the ESP32 to use, and it is set to _I2C_NUM_1_.

_i2c_config_t conf;:_ 
This line declares a structure variable conf of type _i2c_config_t_.
The _i2c_config_t_ structure holds the configuration settings for the I2C bus.

_conf.mode = I2C_MODE_MASTER;:_ 
This line sets the I2C mode to master mode, indicating that the ESP32 will act as the master device in I2C communication.

_conf.sda_io_num = I2C_SDA_IO;:_ 
This line sets the GPIO pin number for the I2C Serial Data (SDA) line to _I2C_SDA_IO_.
The _I2C_SDA_IO_ is a constant that defines the GPIO pin number to be used as the SDA line.

_conf.sda_pullup_en = GPIO_PULLUP_ENABLE;_: 
This line enables the internal pull-up resistor for the SDA line to ensure stable communication.

_conf.scl_io_num = I2C_SCL_IO;:_ 
This line sets the GPIO pin number for the I2C Serial Clock (SCL) line to _I2C_SCL_IO_.
The _I2C_SCL_IO_ is a constant that defines the GPIO pin number to be used as the SCL line.

_conf.scl_pullup_en = GPIO_PULLUP_ENABLE;:_ 
This line enables the internal pull-up resistor for the SCL line to ensure stable communication.

_conf.master.clk_speed = I2C_FREQ_HZ;:_
This line sets the clock frequency for I2C communication to _I2C_FREQ_HZ_.

The _I2C_FREQ_HZ_ is a constant that defines the desired clock frequency for the I2C bus communication.

_i2c_param_config(i2c_master_port, &conf);:_ 
This line applies the I2C configuration settings (conf) to the specified I2C master port _(i2c_master_port)_.

_i2c_driver_install(i2c_master_port, conf.mode, I2C_RX_BUF_DISABLE, I2C_TX_BUF_DISABLE, 0);:_ 
This line installs the I2C driver with the given configuration.

_I2C_RX_BUF_DISABLE_ and _I2C_TX_BUF_DISABLE_ are set to 0, indicating that the I2C master doesn't need any receive or transmit buffers for data.

**I2C Master Write and Read Functions:**
The functions _I2C_Master_Write_Slave_Reg()_ and _I2C_Master_Read_Slave_Reg()_ are utility functions for writing and reading data to/from the ADXL345 accelerometer using I2C communication.

_esp_err_t I2C_Master_Write_Slave_Reg(i2c_port_t i2c_num, uint8_t i2c_addr, uint8_t i2c_reg, uint8_t* data_wr, size_t size):_

The function is declared with the return type esp_err_t, which indicates whether the I2C communication was successful or encountered an error.
The function takes the following parameters:
_i2c_num:_ 

The I2C port number to be used for communication (e.g.,_I2C_NUM_0_ or _I2C_NUM_1_).
_i2c_addr:_

The 7-bit I2C address of the slave device to which data will be written.
_i2c_reg:_ 

The register address in the slave device where the data will be written.
_data_wr:_

A pointer to the data buffer containing the data to be written to the slave device.
size: 
The number of bytes to be written from the data_wr buffer.
_i2c_cmd_handle_t cmd = i2c_cmd_link_create();:_ 

This line creates an I2C command link handle (cmd) that will be used to construct the I2C communication sequence.
_i2c_master_start(cmd);:_ 

This line adds an I2C START condition to the communication sequence, indicating the start of a new transaction.
_i2c_master_write_byte(cmd, (i2c_addr << 1 ) | WRITE_BIT, ACK_CHECK_EN);:_ 

This line sends the 7-bit slave device address with the write bit (0) appended to it, indicating a write operation.
The _ACK_CHECK_EN_ flag enables acknowledgment from the slave device after sending the address.
_i2c_master_write_byte(cmd, i2c_reg, ACK_CHECK_EN);:_ 

This line sends the register address in the slave device where the data will be written.
The _ACK_CHECK_EN_ flag enables acknowledgment from the slave device after sending the register address.
_i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);:_ 

This line writes the specified number of bytes (size) from the data_wr buffer to the slave device's register.
The _ACK_CHECK_EN_ flag enables acknowledgment from the slave device after writing each byte.
_i2c_master_stop(cmd);:_ 

This line adds an I2C STOP condition to the communication sequence, indicating the end of the transaction.
_esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);:_

This line executes the I2C communication sequence represented by the command handle cmd on the specified I2C port (_i2c_num_).
The function will wait for up to 1000 ms for the transaction to complete.
The result of the I2C transaction (success or error) is stored in the variable ret.
_i2c_cmd_link_delete(cmd);:_

This line frees the memory occupied by the I2C command link handle to avoid memory leaks.
_return ret;:_ 

The function returns the value of ret, which indicates the success or failure of the I2C communication. _ESP_OK_ means success, while other error codes indicate specific I2C communication errors.


_esp_err_t I2C_Master_Read_Slave_Reg(i2c_port_t i2c_num, uint8_t i2c_addr, uint8_t i2c_reg, uint8_t* data_rd, size_t size):_
The function is declared with the return type esp_err_t, which indicates whether the I2C communication was successful or encountered an error.
The function takes the following parameters:
_i2c_num:_ The I2C port number to be used for communication (e.g., I2C_NUM_0 or I2C_NUM_1).
_i2c_addr:_ The 7-bit I2C address of the slave device from which data will be read.
_i2c_reg:_ The register address in the slave device from which the data will be read.
_data_rd:_ A pointer to the data buffer where the read data will be stored.
_size:_ The number of bytes to be read from the slave device.

_if (size == 0) { return ESP_OK; }:_
This conditional check ensures that if the requested size is zero (no data to read), the function returns ESP_OK immediately without performing any I2C communication.
_i2c_cmd_handle_t cmd = i2c_cmd_link_create();:_

This line creates an I2C command link handle (cmd) that will be used to construct the I2C communication sequence.
_i2c_master_start(cmd);:_

This line adds an I2C START condition to the communication sequence, indicating the start of a new transaction.
__i2c_master_write_byte(cmd, (i2c_addr << 1), ACK_CHECK_EN);:_

This line sends the 7-bit slave device address with the write bit (0) appended to it, indicating a write operation.
The _ACK_CHECK_EN_ flag enables acknowledgment from the slave device after sending the address.

_i2c_master_write_byte(cmd, i2c_reg, ACK_CHECK_EN);:_
This line sends the register address in the slave device from which the data will be read.
The _ACK_CHECK_EN_ flag enables acknowledgment from the slave device after sending the register address.

_i2c_master_start(cmd);:_
This line adds a repeated I2C START condition to the communication sequence, indicating a repeated start.

_i2c_master_write_byte(cmd, (i2c_addr << 1) | READ_BIT, ACK_CHECK_EN);:_
This line sends the 7-bit slave device address with the read bit (1) appended to it, indicating a read operation.
The ACK_CHECK_EN flag enables acknowledgment from the slave device after sending the address.

_if (size > 1) { i2c_master_read(cmd, data_rd, size - 1, ACK_VAL); }:_
This conditional check ensures that if size is greater than 1, multiple bytes will be read from the slave device.
The i2c_master_read() function reads size - 1 bytes from the slave device and stores them in the data_rd buffer.
The ACK_VAL flag enables acknowledgment from the master after each byte read from the slave.

_i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);:_
This line reads the last byte from the slave device and stores it in the data_rd buffer.
The NACK_VAL flag indicates that no acknowledgment should be sent from the master after reading this byte.

_i2c_master_stop(cmd);:_
This line adds an I2C STOP condition to the communication sequence, indicating the end of the transaction.

_esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);:_
This line executes the I2C communication sequence represented by the command handle cmd on the specified I2C port (i2c_num).
The function will wait for up to 1000 ms for the transaction to complete.
The result of the I2C transaction (success or error) is stored in the variable ret.

_i2c_cmd_link_delete(cmd);:_
This line frees the memory occupied by the I2C command link handle to avoid memory leaks.

_return ret;:_
The function returns the value of ret, which indicates the success or failure of the I2C communication. ESP_OK means success, while other error codes indicate specific I2C communication errors.

_esp_err_t ADXL345_REG_READER(uint8_t REG, uint8_t *P_DATA, uint8_t COUNT):_
The function is declared with the return type esp_err_t, which indicates whether the I2C communication was successful or encountered an error.
The function takes the following parameters:
_REG:_ The register address in the ADXL345 accelerometer from which data will be read.
_P_DATA:_ A pointer to the data buffer where the read data will be stored.
_COUNT:_ The number of bytes to be read from the ADXL345.
The purpose of this function is to read COUNT number of bytes from the register specified by REG in the ADXL345 accelerometer using the I2C communication.

Inside the function, it simply calls the _I2C_Master_Read_Slave_Reg()_ function with appropriate arguments to perform the I2C read operation. The return value from _I2C_Master_Read_Slave_Reg()_ is then returned as it represents the success or failure of the I2C communication.

_esp_err_t ADXL345_REG_WRITER(uint8_t reg, uint8_t *pdata, uint8_t count):_
The function is declared with the return type esp_err_t, which indicates whether the I2C communication was successful or encountered an error.
The function takes the following parameters:
_reg:_ The register address in the ADXL345 accelerometer to which data will be written.
_pdata:_ A pointer to the data buffer containing the data to be written to the ADXL345.
_count:_ The number of bytes to be written to the ADXL345.
The purpose of this function is to write count number of bytes from the pdata buffer to the register specified by reg in the ADXL345 accelerometer using the I2C communication.

Inside the function, it simply calls the _I2C_Master_Write_Slave_Reg()_ function with appropriate arguments to perform the I2C write operation. The return value from _I2C_Master_Write_Slave_Reg()_ is then returned as it represents the success or failure of the I2C communication

**ADXL345 Initialization:**
The function _ADXL345_Initialize()_ configures various registers of the ADXL345 accelerometer to set it up for single tap and double tap detection. It checks the device ID to ensure proper communication with the accelerometer.

_uint8_t val;:_
This line declares a variable val of type uint8_t to store temporary data read from or written to the ADXL345 registers.

_char *TAG = "ADXL345";:_
This line declares a character pointer TAG and assigns it the value "_ADXL345_".
The _TAG_ is used for logging purposes to identify the source of log messages.

_ADXL345_REG_READER(DEVICE_ID, &(val), 1);:_
This line calls the ADXL345_REG_READER() function to read the device ID register (DEVICE_ID) of the ADXL345.
The function reads one byte of data from the register and stores it in the variable val.

_if (val == 0xE5) { ESP_LOGI(TAG, "ADXL345 ID:0x%X (OK)", val); } else { ESP_LOGE(TAG, "ADXL345 ID:0x%X !!!! (NOT correct; should be 0xE5)", val); }:_
This conditional statement checks whether the device ID read from the ADXL345 is correct (0xE5).
If the device ID is correct, it logs an informational message using _ESP_LOGI()_, indicating successful initialization.
If the device ID is not correct, it logs an error message using _ESP_LOGE()_, indicating an issue with the ADXL345 communication or device configuration.

**GPIO Interrupt Handlers:**
The code defines two interrupt handlers (_single_isr_handler_ and _double_isr_handler_) that get triggered when the   _INT_1_ and _INT_2_ GPIO pins change their state. These handlers set flags (_single_flag_ and _double_flag_) to indicate that single tap  or double tap has been detected.

_void IRAM_ATTR single_isr_handler(void* arg):_
This function is an interrupt service routine (ISR) that handles the interrupt triggered when single tap is detected by the ADXL345 accelerometer.
The _IRAM_ATTR_ attribute is used to place the ISR in the IRAM (Internal RAM) section, which improves the ISR's execution time and reduces latency.
The ISR does not take any arguments _(void* arg)_ because it is a simple handler for the single tap interrupt.

Inside the ISR, the following actions are performed:
_single_flag = 1;:_ The variable single_flag is set to 1, indicating that single tap has been detected.
_double_flag = 0;:_ The variable double_flag is set to 0, indicating that double tap  is not detected.

_void IRAM_ATTR double_isr_handler(void* arg):_
This function is an interrupt service routine (ISR) that handles the interrupt triggered when inactivity is detected by the ADXL345 accelerometer.
The _IRAM_ATTR_ attribute is used to place the ISR in the IRAM (Internal RAM) section, which improves the ISR's execution time and reduces latency.
The ISR does not take any arguments _(void* arg)_ because it is a simple handler for the double tap interrupt.

Inside the ISR, the following actions are performed:
_double_flag = 1;:_ The variable double_flag is set to 1, indicating that double tap has been detected.
_single_flag = 0;:_ The variable single_flag is set to 0, indicating that single tqp is not detected.

**GPIO Configuration:**
The function _ISR_GPIO()_ configures the GPIO pins (_INT_1_ and _INT_2_) as input pins with interrupt-on-any-edge functionality. It installs the interrupt service routine (ISR) handlers for both pins to detect single tap and double tap.

_gpio_config_t io_conf;:_
This line declares a structure io_conf of type gpio_config_t, which holds the configuration settings for the GPIO pin.

_Configuring INT_1 GPIO pin for single tap detection:_
_io_conf.intr_type=GPIO_INTR_ANYEDGE;:_ This line sets the interrupt trigger type to "ANYEDGE," meaning the ISR will be triggered on both rising and falling edges of the GPIO pin.
_io_conf.pin_bit_mask = (1ULL << INT_1);:_ This line sets the bit mask to select the INT_1 GPIO pin as the interrupt source. The INT_1 macro represents the GPIO pin number for activity detection.
_io_conf.mode = GPIO_MODE_INPUT;:_ This line sets the GPIO pin mode to "INPUT," as it is used to detect the state changes from the ADXL345 accelerometer.
_io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;:_ This line disables the pull-down resistor for the GPIO pin to avoid any unwanted behavior.
_io_conf.pull_up_en = GPIO_PULLUP_DISABLE;: _This line disables the pull-up resistor for the GPIO pin for similar reasons.
_gpio_config(&io_conf);: _This line applies the GPIO configuration settings to the INT_1 GPIO pin.
Configuring _INT_2 GPIO_ pin for inactivity detection:

The code for configuring _INT_2 GPIO pin_ is identical to the configuration of_ INT_1_, except it uses the _INT_2_ macro to represent the GPIO pin number for double tap detection.
_gpio_install_isr_service(0);:_

This line installs the GPIO ISR service, enabling the use of GPIO interrupts in the application.
The argument 0 indicates the default ISR service queue. If multiple ISR services are used, different queue numbers can be specified.
Registering ISRs for INT_1 and INT_2 GPIO pins:

_gpio_isr_handler_add(INT_1, single_isr_handler, (void*)INT_1);:_ This line registers the single_isr_handler function as the ISR for the _INT_1_ GPIO pin. The ISR will be called when the INT_1 GPIO pin triggers an interrupt. The _(void*)INT_1_ argument is used to pass the _INT_1_ macro value as a parameter to the ISR function (if needed).

_gpio_isr_handler_add(INT_2, double_isr_handler, (void*)INT_2);:_ This line registers the double_isr_handler function as the ISR for the _INT_2_ GPIO pin. The ISR will be called when the INT_2 GPIO pin triggers an interrupt. The _(void*)INT_2_ argument is used to pass the _INT_2_ macro value as a parameter to the ISR function (if needed).

**Main Function:**
In the _app_main()_ function, the code performs the following tasks:

Calls the initialization functions for I2C, ADXL345, and GPIO.

Enters an infinite loop to continuously read data from the accelerometer.

Checks the interrupt flags to print messages when single tap or double tap is detected.

Prints the value of the _INT_SOURCE_ register to indicate the accelerometer's interrupt status.

Adds a delay using _vTaskDelay(_) to control the sampling frequency.
